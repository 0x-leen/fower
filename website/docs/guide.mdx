---
id: guide
title: guide
---

在[快速开始](/docs/getting-started)中，我们体验了 Styli 的最基本用法，接下来我们看看 Styli 的其他用法。

### 基本用法

为了让你深入理解 Styli 的用法，我们来回顾一下基本用法:

```jsx live
<Text f-24 fontBold green500>
  Hi, Styli
</Text>
```

Styli 最简单的用法是直接在 Styli 组件设置一些原子属性，上面 `f-24 fontBold green500` 会生产下面的样式：

```jsx
<span
  style={{
    fontSize: '24px',
    fontStyle: 'bold',
    color: '#276749',
  }}
>
  Hi, Styli
</span>
```

上面的 Props `f-24 fontBold green500` 不需要声明 value，我们称之为 "**Key as Value**" 模式，这让 UI 代码更简洁，提高了开发体验。个人认为，JSX 内联样式本身已经很不错，有强类型，方便做动态样式，最大缺点是繁琐啰嗦和视觉上的干扰，没人喜欢 `style={{}}` 这样丑陋的样板代码，而 Styli 解决了这些问题，使用 Styli，每个字符都是有意义的，没有多余的等号、花括号、引号等无用的字符，保持了 JSX 结构的简洁。

> `f-24` f 是 fontSize 的缩写，为了更简洁和开发效率，我们会把 `margin padding width heigth fontSize` 等高频出现的属性简化了一个字符。

### 声明单位

默认原子属性不需要带单位，如果有需要，你可以声明明确的单位:

```jsx live
<View center>
  <View s-100 bgBlue200 mr-10>
    默认
  </View>
  <View s-120px bgBlue200 mr-10>
    px
  </View>
  <View s-5rem bgBlue200 mr-10>
    rem
  </View>
  <View s-6em bgBlue200 mr-10>
    em
  </View>
</View>
```

### 使用属性值

大部分情况，我建议"**Key as Value**" 模式来设置样式，有些场景我们需要通过设置属性值来编写样式:

```jsx live
function Demo() {
  const a = 5
  const b = 5
  return (
    <Text f={30} p={a + b} bg="#bee3f8" fontBold>
      Hi, Styli
    </Text>
  )
}
```

**传值**模式损失了一部分简洁性，但是更加灵活，特别适合用在动态样式场景。

### 动态样式

根据应用的状态控制组件的样式，我们称之为动态样式，典型的场景就是按钮的激活状态。因为 JS 变量无法传递到 CSS，传统的方式，我们会通过控制 CSS 类实现动态样式。

你应该见过类似下面的代码：

```jsx live
function App() {
  const [isActive, setIsActive] = useState(false)
  return (
    <button
      className={`btn ${isActive ? 'btn-active' : ''}`}
      onClick={() => {
        setIsActive(!isActive)
      }}
    >
      It is {isActive ? 'on' : 'off'}!
    </button>
  )
}
```

我们通过 `.btn` 和 `.btn-active` 两个 CSS 类控制动态样式，这有什么问题呢？这是让我们封装的组件严重依赖外部的样式代码，失去独立性，不够内聚。如果存在更多的样式状态，代码的可读性会越来越低。另外，这种方式可移植性也很差。

CSS 类这种动态样式的处理方式，和 React 的理念 `UI=f(State)` 也是相违背的，因为外部 CSS 的变更，会导致 `UI=f(State)` 中的 UI 发生变化。

那我们是不会基于内联样式处理动态样式呢？确实可以。代码如下：

```jsx live
function App() {
  const [isActive, setIsActive] = useState(false)
  return (
    <button
      style={{
        padding: '15px',
        color: isActive ? '#fff' : '#000',
        background: isActive ? '#276ef1' : 'none',
        borderRadius: '4px',
        border: '1px solid #aaa',
      }}
      onClick={() => {
        setIsActive(!isActive)
      }}
    >
      It is {isActive ? 'on' : 'off'}!
    </button>
  )
}
```

这种方式有一些优点：1.很轻易把 JS 状态变量传递给 CSS; 2. 和 `UI=f(State)` 的理念相符合；3. 可移植性强。但是内联样式也有一些非常严重的局限性：例如，您不能使用伪选择器之类的:hover 或媒体查询。另外，内联样式很容易让组件的结构变得混乱，视觉上干扰代码阅读。

那使用 Styli 如何处理动态样式呢？Styli 使用**属性值**的模式，让动态样式处理符合 `UI=f(State)` 理念，并且代码比内联样式更加简洁。

```jsx live
function App() {
  const [isActive, setIsActive] = useState(false)
  return (
    <Button
      p-15
      rounded-4
      borderGray200-1
      color={isActive ? '#fff' : '#000'}
      bg={isActive ? '#276ef1' : false}
      onClick={() => setIsActive(!isActive)}
    >
      It is {isActive ? 'on' : 'off'}!
    </Button>
  )
}
```

### Styled Component

`styled` 可以让第三方组件使用原子属性样式。

```jsx
import { styled } from '@styli/core'
import { Button } from 'antd'

const StyledButton = styled(Button)

function Demo() {
  return (
    <div>
      <StyledButton p-10>click me</StyledButton>
    </div>
  )
}
```

### createStyle

```jsx live
function Demo() {
  const cardStyle = createStyle('p-20 bgOrange200')
  const textStyle = createStyle('p-10 pink500')
  return (
    <div style={cardStyle}>
      <span style={textStyle}>Style from createStyle</span>
    </div>
  )
}
```

### 样式组件复用

当一个组件用到特别多的原子属性，并且这个样式会多个组件用到，这时建议创建一个自定义组件。

```jsx
import React from 'react'
import { Button } from '@styli/react'

export default (props) => {
  return <Button {...props} p-10 f-18 bgYello400 white rounded-8 />
}
```

### CSS Props

```jsx
<Text
  p-10
  css={{
    textShadow: '1px 1px 2px pink',
    textTransform: 'uppercase',
  }}
>
  Hi, Styli
</Text>
```

### 伪类

```jsx
<Text
  p-10
  pink
  css={{
    textShadow: '1px 1px 2px pink',
    textTransform: 'uppercase',
    '&:hover': {
      color: 'red',
    },
  }}
>
  Hi, Styli
</Text>
```
