---
id: principle
title: 原理
---

## 核心

Styli 实现原理非常简单。

> - 遍历了每一个组件上的 prop
> - 对 prop key 进行规则匹配
> - 匹配到后，对 prop key 进行收集，对 prop value 进行意义转换
> - 将每一个匹配到的 prop value 转换结果进行整合
> - 构造最终的 props

```ts
const rules = [] // Styli 匹配规则
const matchKey = [] // 收集 Styli 匹配到的 prop Key
const style = {} // Styli 属性转换后的样式
const finalProps = {} // 最终组件 props

// 遍历、转换和收集
for (const [propKey, propValue] of Object.entries(props)) {
  for (const rule of rules) {
    const { isMatch, toStyle } = rule
    if (isMatch(propKey)) {
      matchKey.push(propKey)
      Object.assign(style, toStyle(propKey, propValue))
      break
    }
  }
}

// 过滤出 Styli 没有匹配到的属性
for (const [propKey, propValue] of Object.entries(props)) {
  if (!matchKey.includes(propKey)) {
    finalProps[propKey] = propValue
  }
}
```

## 媒体查询、伪类和设计系统

遍历 props 与规则，在 prop 进行 toStyle 前，我们可以对 prop key 或 prop value 进行拆分和构造，即可实现媒体查询、伪类和设计系统。

```ts
const breakpoints = [10, 20, 30, 40] // 媒体查询断点
const style = {} // style 需要自定义数据结构，以后续解析伪类、媒体查询等..

for (const [propKey, propValue] of Object.entries(props)) {
  for (const rule of rules) {
    const { isMatch, toStyle } = rule

    // 伪类对 prop key 进行拆分
    if (isPseudo(propKey)) {
      const [key, pseduo] = parseKey(propKey)
      if (isMatch(key)) {
        matchKey.push(propKey)
        style[pseduo] = toStyle(key, propValue)
        break
      }
    }

    // ----设计系统同伪类对 prop key

    if (isMatch(propKey)) {
      // 媒体查询对 prop value 进行拆分
      if (Array.isArray(propValue)) {
        matchKey.push(propKey)
        propValue.reduce((finalStyle, cur, idx) => {
          return Object.assign(finalStyle[breakpoints[idx]], toStyle(propKey, cur))
        }, style)
        break
      }

      matchKey.push(propKey)
      Object.assign(style, toStyle(propKey, propValue))
      break
    }
  }
}
```

## 内联样式

将 Styli 生成的 style 与组件上的原始 style 进行整合即可得到最终的 style。

```ts
// 添加和整合 style 属性
Object.assign(finalProps['style'], style, props.style)
```

注意: 篇幅有限，没有写过滤媒体查询、伪类等内容。

## 外部样式

当我们为组件生成一个 className，并把 Styli 转换后的样式编码成 css 字符串，添加到 HTML 的 style 属性下，最后将 className 整合到 finalProps 上，即可引用外部样式。

```ts
// 生成当前组件 className
const componentId = generateComponentId(props)
const className = generateClassName(componentId)

// 将样式编码成字符串
const cssStr = parseStyleToStr(style, className)

// 将 cssStr 添加到 HTML 的 style 标签下
$style.innerHTML = $style.innerHTML + cssStr

// 整合 className
finalProps['className'] = `${className} ${props.className || ''}`
```

注意: 篇幅有限，没有写过滤相同 className 的内容。

## 性能

可以想象，每一个组件的每一个 prop 都需要经过 Styli 的 n 个规则匹配和转换，尤其是在 React 中，由 state 变化引起的 n 次渲染，每次渲染都会遍历 prop 与规则，这些无疑对性能消耗巨大。

**我们建立了应用级的缓存，Styli 对遍历过的每一个 prop，都会将其进行缓存，之后无论是重新渲染，还是遍历 n 个组件之后的相同 prop, Styli 会直接从缓存中取出结果进行响应。**
